# 4/28/2025 4:52 PM
I just finished reading over the project description again so that I can understand exactly what needs to be done. From what I understand so far, this project deals with storing information in a B-Tree and being able to perform various operations to access/modify that information. There also seem to be strict rules on the headers of the file and different nodes within the tree. I think that my initial plan to start this project is to watch a video to fully understand B-Trees more so I can understand how the different operations need to be performed. Then, I want to just get the project started by creating the template for each of the commands and maybe implementing the create command, based on how much time I have.

# 4/29/2025 7:40 PM
I was able to get the basic structure of the code set up yesterday, so just the "menu" and taking in the different command line arguments and then making placeholder functions. Now, I want to implement the create command properly. I think this will be a little tricky because I have to figure out how to properly implement the header logic. I think that once I figure out how to interact with the index file properly, the rest of the project should make a lot more sense. As of now, I understand that it's somewhat similar as writing to a csv file but I am writing bytes instead of just writing the input that I get. I'm not sure how to create different blocks of text and be able to read them in for later when I do the insert. But right now, I just want to do the creation of the file and set up the header. 

# 4/29/2025 8:17 PM
I think I was able to properly create the file with the header as specified. I did this by creating a bytearray of size 512 and the modifying different parts of it to be what I wanted. I think that this is the technique that I'll end up using whenever I make blocks/nodes to go in the B Tree. I think the next command I want to somewhat figure out is insert, but I definitely think this will be the hardest. So essentially, I know that each node can have 19 key/value pairs and this is written in its 512 bytes. Actually, now that I'm thinking about it, I think the search function needs to be done first, so that I am not inserting duplicates. So with the search, I think I just have to look at the key of each node and then figure out if I need to go to the left or right. 

# 4/29/2025 8:51 PM
I got the search functionality working (I think - I am not able to fully test because I don't have insert yet). Basically, it just makes sure the index file exists and is the right format before performing a binary search on the keys until it finds the one it's searching for, if it exists. I also got the implementation for the load working. It basically just reads in from the csv and passes to the insert function as long as the key/value pair is formatted correctly. The load function doesn't directly deal with the B Tree so it was pretty easy to implement. I think I'm going to write to get the print/extract functionality working as well (because they should both be very similar). I definitely want to leave insert until the end because it is going to be the toughest to do because I have to figure out how to split nodes and move blocks around as well. 

# 4/29/2025 9:24 PM
I think I finished the print and extract functions. Again, I'm not 100% sure that it works perfectly because I don't have the insert functionality figured out but I think that the logic of it makes sense. The extract function just calls the print function but with another optional parameter so that it writes to a file and not standard output. The print function performs an in order traversal of the B tree and prints out the key/value pairs, so that means that it should print out in sorted order because it prints left subtree, node, right subtree. I'll go back and fully test this once I have the insert functionality implemented. But I think that I'll revisit this and do that at another time because it's going to require the most work.

# 5/3/2025 7:12 PM
Okay, today I am working on the insert function which is definitely going to be the hardest because I have to figure out how to split and promote each of the nodes. I'm definitely a little sacred in figuring out this logic becasue I feel like it's also going to be hard to figure out how this interacts with the index file. So from the specifications, the format of a node is its ID, parent, the number of keys and then keys, values and children. First, I am going to start out with just trying to insert one node at the root and then figure out how to insert multiple with splitting/promoting. Then, once that is figured out, I'll figure out how to add the promotions to my code.

# 5/3/2025 8:16 PM
I think that I have the first part of the logic figured out. First, I added a check to see if that node already exists and if it does, then the code just prints that it found the node and exits. Then, if it's the first node that I am inserting, I allocate space for that block, create all of the necessary information that goes into the block, and write that block to the tree. I also have to update the header so I can keep track of which node is the root and which is going to be allocated next, so that information is sent back to the header. If it's not the root, then I call the insert recursive function which gets the block, figures out where the new key should go and just adds in into place. This is where I would have to add in a check to make sure that there is still space and if not, then I would have to split and figure out how to promote a certain node. 

# 5/4/2025 5:25 PM
For today I want to figure out how to implement splitting/promoting a node so that I can finish up the project. I think that for this, I basically have to figure out if the node has hit its max capacity or not and if it has then I have to figure out how to split. The part that I am confused about is the constraint that we can only have 3 nodes in memory at a time. So, I guess that means the left, right and the promoted node. So, I need to make sure that I track when a node is read, processed and written and make sure that this doesn't exceed the constraints that were given. I think that once I figure out how to make the splitting logic right, I should be in a good place to finalize the rest of the functionality. 

# 5/4/2025 9:51 PM
I think that I have most of the core insertion logic finally working. Right now, instead of 19 keys and 20 children, I am just using 3 keys and 4 children to test if it works when I manually insert nodes so that it's more manageable. A big issue that I kept running into was overwriting the header of the file. This was really confusing because whenever I tried to do an insert after the overwrite it kept telling me that the index file was invalid. I couldn't figure out why though because this would only happen on the third or fourth insert so I was confused why it was giving me an error at that time. I finally ended up figuring out that the issue was because I was letting the allocate_block() function assign block ID 0 which is where the header is and fixed this by making sure that it was always at block 1. I also was having some issues with the parent pointer updates because I initially skipped this process and was getting confused why some of the references were wrong later on but I addressed this by adding explicity reads and rewrites of the child's block with parent_id. I also am still not sure if I am violating the 3 node memory constraint so I need to go back and trace the code to make sure that I am good in that sense. I also haven't really tested out the load functionality because I've only been doing the inserts manually. But I did test out the print and extract functions so I know that it's at least able to save once the tree is built. From what I can tell the insert now seems like it works but I definitely need to keep testing and trace the code to double triple check that it's all good. This was definitely the hardest part of the project because I am viewing the index file through a hex file extension and each time that I mess up and need to regenerate it, I need to generate more and more files and it's also just hard to read through it and figure out where one block ends and one block starts and also keeping track of who is whose parent/child. 